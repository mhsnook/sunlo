# Sprint Doc

## Completed items list:

Update this list with complexity and difficulty scores after completing an item.

- [x] J: GitHub actions for CI/CD
- [x] K: Navigating-around-the-app tests
- [x] AC: Retire PLv8, rewrite functions

## Instructions for the coding agent

Under normal circumstances:

- See the document: `@/contexts/instructions-for-coding-agent.md`

If you have been instructed to do a BIG ITEMS PASS, then do one thing differently: start first by looking at the items that are marked as BIG ITEMS, or that you can see require analysis or have a complexity of 3 or 4. Otherwise, work through the doc item by item picking the ones most relevant to you, as you normally would, but not writing any code or doing any git commits, simply leaving your analysis and plans on these items and moving on.

## BIG ITEMS

- J: GitHub actions for CI/CD
- K: Navigating-around-the-app tests
- AC: Retire PLv8, rewrite functions

## Items to Work On

### Feature E: Friends feed and Popular feed should become polymorphic like the recent feed, and Filters should work there too

STATUS: PENDING
COMPLEXITY: 2

NOTE: The router's fallback loading component wasn't using the standard Loader component; switching to that fixed it.

### Feature Research H: User Consents and GDPR

STATUS: PENDING
COMPLEXITY: 1 or 3

HUMAN MANAGER COMMENT: Now that we have a "public mode" we have an increased responsibility and urgency around implementing some more explicit permissions and consents. For example, the privacy policy in `privacy-policy.tsx` specifies that phrases and translations will be public, but we should make this more clear that e.g. comment threads, requests and playlists are also part of the public resources. Which cards you're learning and your review history are private, but many of these other things can be read by the public. Giving some checkbox notification of this, on the signup form, should be a simple client-side change (complexity 1).

And in time we also need to implement some GDPR compliance, which means having a model for consents and consent-agreement actions that can be tied back to the version of the policy that was being consented to. Which means probbly moving the privacy policy into the database as markdown and versioning it and so on. This will be a much more involved project than simply better notifying the users about sharing information in public, and should be well thought out before we begin.

### Feature I: Sign in with Google Auth

STATUS: Pending
COMPLEXITY: 2

HUMAN MANAGER COMMENT: This may require some back-and-forth with Supabase setup and configuration, and then writing code. And we may need to give individuals a way to switch from password-auth to google-auth.

### DX J: Explain what it would take to set up GH Actions to run tests

STATUS: IMPLEMENTED
COMPLEXITY: 2
DIFFICULTY: 2

HUMAN MANAGER COMMENT: This may look like a complexity 1 ("set up a github action") but we have to be very careful never to run the tests against the production branch. We need to run them against the `next` branch and against PRs targeting `next` and against any deployment PRs (from `next` to `main`). The action needs to be able to use secrets that are synced from Supabase's branch management system, or if that proves to complex, use secrets that work for the `next` branch, and use supabse's persistent `next` branch to achieve the best coverage within our limitations. Please collect a few reasonable options and present them. Go with a minimal solution that works first; a basic POC that is safe and reliable and uses the `next` branch only, and we can do that first, and then we'll work on better test reliability (or else our new CI pipeline will shut down all deployments!) and then we'll think about other DX improvements in a later scope of work. Don't make any code changes yet; simply write a plan in this doc.

#### ANALYSIS (2026-01-15)

**Current State:**

- Existing `.github/workflows/cloud-publish.yaml` handles Tauri releases (triggers on `release` branch)
- Playwright config already has CI-aware settings (`forbidOnly`, `retries: 2`, `workers: 1`)
- Tests require local Supabase (db reset via `pnpm supabase db reset`)
- Global setup already supports `SKIP_DB_RESET` env var

**Options Considered:**

1. **Local Supabase in CI (Recommended for MVP)**

   - Start Supabase via Docker in the GitHub Action
   - Run `supabase db reset` to seed
   - Run tests against local instance
   - Pros: Fully isolated, no risk to production, deterministic
   - Cons: Slower (~2-3 min for Supabase startup), requires Docker

2. **Supabase Branch Secrets**

   - Use Supabase's branch management to get secrets for `next` branch
   - Pros: Tests against real infrastructure
   - Cons: More complex secret management, potential race conditions if multiple CI runs

3. **Dedicated Test Project**
   - Separate Supabase project just for CI
   - Pros: Isolated from all environments
   - Cons: Extra cost, maintenance burden

**Recommended Plan (MVP):**

```yaml
# .github/workflows/test.yaml
name: Tests
on:
  push:
    branches: [next]
  pull_request:
    branches: [next, main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
        with:
          version: 9
      - uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'
      - uses: supabase/setup-cli@v1
        with:
          version: latest
      - run: pnpm install --frozen-lockfile
      - run: supabase start
      - run: pnpm test
      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
```

**Key Safety Measures:**

- Only triggers on `next` branch and PRs to `next`/`main`
- Uses local Supabase (zero production risk)
- Playwright report uploaded as artifact for debugging

**Future Enhancements (after MVP works):**

1. Add navigation-only tests (item K) for faster feedback
2. Cache Docker layers for faster Supabase startup
3. Consider matrix testing across browsers
4. Add test sharding for parallel execution

#### IMPLEMENTATION (2026-01-15)

Created `.github/workflows/test.yaml` with the MVP approach:

- Triggers on push to `next` and PRs targeting `next` or `main`
- Uses local Supabase via Docker (zero production risk)
- Extracts keys from `supabase status` dynamically
- Installs Playwright browsers with dependencies
- Uploads Playwright report as artifact (30-day retention)
- Uses concurrency groups to cancel in-progress runs on new pushes
- 20-minute timeout as safety measure

### DX K: A set of tests that don't make database changes; ignores the `mutations` folder and uses a different `navigations` folder which just steps through the app, allowing decs to run these tests frequenty without a db reset, using `pnpm test no-db`

STATUS: IMPLEMENTED
COMPLEXITY: 2
DIFFICULTY: 2

NOTE FROM HUMAN MANAGER: We can mostly copy the navigation commands from existing "mutations" tests, and just leave out the form stuff. And we can just click around key workflows and make sure everything works. Maybe you have a smart way of just "crawling" the app from both logged-in and logged-out perspectives and spotting anything unusual.

#### ANALYSIS (2026-01-15)

**Current State:**

- `e2e/mutations/` folder contains 9 test files that make DB changes (cards, decks, feed, onboarding, phrases, playlists, profile, requests, reviews, social)
- `e2e/login-flow.spec.ts` and `e2e/example.spec.ts` are lightweight and mostly read-only
- `global-setup.ts` already supports `SKIP_DB_RESET` env var
- CLAUDE.md states: "NEVER use `page.goto()` - always click through UI"

**Test Structure to Create:**

```
e2e/
├── mutations/          # Existing - requires db reset
├── navigations/        # New - no db changes
│   ├── logged-out.spec.ts
│   ├── logged-in.spec.ts
│   └── deck-workflows.spec.ts
├── example.spec.ts
├── login-flow.spec.ts
└── global-setup.ts
```

**Implementation Plan:**

1. **Create `e2e/navigations/` folder** with read-only tests

2. **Add npm script** in package.json:

   ```json
   "test:nav": "SKIP_DB_RESET=1 playwright test --ignore-snapshots e2e/navigations e2e/example.spec.ts e2e/login-flow.spec.ts"
   ```

3. **logged-out.spec.ts** - Public pages crawl:

   - Visit `/` and verify landing page
   - Navigate to `/learn` (now public)
   - Click through language list, verify phrase counts display
   - Visit `/learn/$lang/browse` and verify phrase cards render
   - Check that "Log in" prompts appear on protected actions
   - Visit `/learn/$lang/feed` and verify feed items render

4. **logged-in.spec.ts** - Authenticated navigation:

   - Log in as test user
   - Verify deck list appears on `/learn`
   - Click into each deck, verify stats display
   - Navigate to browse page, verify cards with user's card status
   - Visit profile page, verify preferences load
   - Click through sidebar nav items

5. **deck-workflows.spec.ts** - Core workflows without mutations:
   - Log in, navigate to a deck
   - Click "Start Review" - verify review page loads (but don't submit)
   - Navigate to browse, use search/filter UI (verify reactivity)
   - Visit phrase detail pages via clicks
   - Check feed page loads with items

**Key Patterns to Use:**

```typescript
// Good - navigate by clicking
await page.getByRole('link', { name: /browse/i }).click()

// Bad - bypasses router
await page.goto('/learn/hin/browse')
```

**Expected Benefits:**

- Run in ~30 seconds vs ~3 minutes (no db reset)
- Catch routing/rendering regressions quickly
- Safe to run repeatedly during development
- Can run in CI as a fast "smoke test" before full suite

**Considerations:**

- Tests assume seed data exists (run `pnpm test` once first)
- Tests should not assert on exact counts (data may vary)
- Use presence checks (`toBeVisible`) not value checks where possible

### L. Fix: When you get login-requred intercepted on the add-phrase page and then log in, the sidebar does not update unless you refresh

STATUS: Pending
COMPLEXITY: 2

#### NOTE FROM HUMAN MANAGER

This login results in a whole bunch of this console warning from tanstack/db:

> [Live Query Error] Source collection 'my_profile' was manually cleaned up while live query 'live-query-4' depends on it. Live queries prevent automatic GC, so this was likely a manual cleanup() call.

And

> [Live Query Error] Source collection 'decks' was manually cleaned up while live query 'live-query-9' depends on it. Live queries prevent automatic GC, so this was likely a manual cleanup() call.

And so on.

### S. Feature: Reverse Reviews

STATUS: Still defining the problem / desired behaviour
COMPLEXITY: 2

NOTE FROM HUMAN MANAGER: the card shouldn't always be shown on the front, should it? sometimes we need to see the translation and remember the phrase (or see the request??). What do you think?

### V. Fix: When you try to "sign up" using credentials of an existing user, you get an error but then still get logged in. We should probably inspect these errors, and if it's this specific case, just log you in and don't throw the error/toast.

STATUS: PENDING
COMPLEXITY: 1

### W. Feature: Edit or soft-delete your own translations

STATUS: PENDING
COMPLEXITY: 2

NOTE FROM HUMAN MANAGER: This should be a simple update call (no RPC needed) to edit the translation item, and then we have to do a tiny bit of fanciness to update the local Phrase item with just the translation we've changed (or to remove it), and update the `phrase_translation` RLS so that archived/deleted rows don't show up. So it all seems very small but several layers must be done together.

### X. Chore: 1. Replace the friend request / accept / cancel logic with a dedicated RPC

STATUS: PENDING
COMPLEXITY: 2 (simple enough, but requires migrations and checking state/idempotence/edge cases (like both people sending requests at the same time))

### AC. Chore: Convert RPCs from now-deprecated PLv8 fns to PLpgpsql

STATUS: IMPLEMENTED
COMPLEXITY: 2
DIFFICULTY: 2

#### ANALYSIS (2026-01-15)

**Current PLv8 Functions (from migrations):**

Located in `supabase/migrations/20250120164928_fsrs_helpers_plv8.sql` and `20250120164929_fsrs_main_rpc_plv8.sql`:

1. **Helper Functions (pure math, no DB access):**

   - `fsrs_clamp_d(difficulty)` - Clamp difficulty to [1, 10]
   - `fsrs_d_0(score)` - Initial difficulty calculation
   - `fsrs_delta_d(score)` - Difficulty delta
   - `fsrs_dp(difficulty, score)` - Difficulty prime
   - `fsrs_difficulty(difficulty, score)` - New difficulty after review
   - `fsrs_interval(desired_retrievability, stability)` - Calculate review interval
   - `fsrs_retrievability(time_in_days, stability)` - Current retrievability
   - `fsrs_s_0(score)` - Initial stability (lookup from W array)
   - `fsrs_s_fail(d, s, r)` - Stability after failed review
   - `fsrs_s_success(d, s, r, score)` - Stability after successful review
   - `fsrs_stability(d, s, r, score)` - Wrapper for fail/success

2. **Main RPC (DB access):**
   - `record_review_and_schedule(user_card_id, r, score)` - Records review and calculates next schedule

**FSRS Constants Used (hardcoded in functions):**

```
W_4 = 7.1949, W_5 = 0.5345, W_6 = 1.4604, W_7 = 0.0046
W_8 = 1.54575, W_9 = 0.1192, W_10 = 1.01925
W_11 = 1.9395, W_12 = 0.11, W_13 = 0.29605, W_14 = 2.2698
W_15 = 0.2315, W_16 = 2.9898
W = [0.40255, 1.18385, 3.173, 15.69105] (initial stability by score)
f = 19.0 / 81.0, c = -0.5 (retrievability constants)
```

**Migration Plan:**

1. **Create new migration file** `YYYYMMDD_fsrs_plpgsql.sql`

2. **Convert helper functions to PLpgSQL:**

   ```sql
   -- Example conversion of fsrs_clamp_d
   create or replace function public.fsrs_clamp_d (difficulty numeric) returns numeric language plpgsql immutable as $$
   BEGIN
     RETURN LEAST(GREATEST(difficulty, 1.0), 10.0);
   END;
   $$;
   ```

3. **Key translation patterns:**

   - `Math.min/max` → `LEAST/GREATEST`
   - `Math.pow` → `POWER()`
   - `Math.exp` → `EXP()`
   - JavaScript ternary → `CASE WHEN ... THEN ... ELSE ... END`
   - `plv8.find_function("fn")()` → Direct function call `fn()`
   - `plv8.execute()` → Regular SQL statements

4. **Add `IMMUTABLE` modifier** to pure math functions (enables query planner optimization)

5. **Convert main RPC:**

   ```sql
   CREATE OR REPLACE FUNCTION public.record_review_and_schedule(...)
   RETURNS timestamp without time zone
   LANGUAGE plpgsql
   AS $$
   DECLARE
     last_review RECORD;
     new_stability numeric;
     new_difficulty numeric;
     new_interval_r90 numeric;
     scheduled_for timestamp;
   BEGIN
     SELECT ... INTO last_review FROM user_card_scheduled ...;

     IF last_review IS NOT NULL THEN
       new_stability := fsrs_stability(...);
       new_difficulty := fsrs_difficulty(...);
     ELSE
       new_stability := fsrs_s_0(score);
       new_difficulty := fsrs_d_0(score);
     END IF;

     new_interval_r90 := fsrs_interval(0.9, new_stability);
     scheduled_for := NOW() + (new_interval_r90 * INTERVAL '1 day');

     INSERT INTO user_card_scheduled (...) VALUES (...);

     RETURN scheduled_for;
   END;
   $$;
   ```

6. **Drop PLv8 extension** at end of migration:
   ```sql
   drop extension if exists plv8;
   ```

**Testing Strategy:**

- Create test cases with known inputs/outputs before migration
- Run FSRS calculations through both implementations
- Compare results (should be identical within floating point tolerance)
- Existing e2e review tests will validate end-to-end behavior

**Benefits of Migration:**

- No PLv8 extension dependency (simpler deployment)
- Better query planner integration with `IMMUTABLE` functions
- Native Postgres - better debugging and profiling
- Potentially faster execution (no JS VM overhead)

**Estimated Effort:** 2-3 hours for conversion + testing

#### IMPLEMENTATION (2026-01-16)

**Approach: Client-side FSRS with server-side validation**

After analysis, we chose to move FSRS calculations entirely to the client side. This aligns with the project's "Local First Approach" philosophy and provides:

- Type-safe calculations in TypeScript
- Instant feedback (no server round-trip for calculation)
- Easier testing and debugging
- Simpler server-side RPCs that just validate and store

**Files Created:**

1. `src/lib/fsrs.ts` - Complete TypeScript port of FSRS algorithm

   - Exports `calculateFSRS(input: FSRSInput): FSRSOutput`
   - Exports `validateFSRSValues()` for client-side validation
   - Exports `retrievability()` helper for UI display

2. `supabase/migrations/20260116000000_client_side_fsrs.sql`
   - Replaces PLv8 `insert_user_card_review` with simplified PLpgSQL that accepts pre-calculated values
   - Replaces PLv8 `update_user_card_review` similarly
   - Adds server-side bounds validation (difficulty 1-10, stability 0-36500, etc.)
   - Drops all PLv8 FSRS helper functions
   - Drops PLv8 extension

**Files Modified:**

1. `src/hooks/use-reviews.ts`

   - `postReview()` now calculates FSRS client-side before RPC call
   - `updateReview()` similarly updated
   - Added `useLatestReviewForPhrase(pid)` hook for getting previous review data
   - `useReviewMutation()` signature updated to accept `latestReview` parameter

2. `src/components/review/review-single-card.tsx`
   - Added `useLatestReviewForPhrase()` hook call
   - Passes `latestReview` to `useReviewMutation()`

## Items that still need to be figured out

Feeds Work Cleanup tasks:

2. Need to be able to "repost" a Request to a new language
3. Playlists should have an image option if you don't have an external source with og:image

EPIC: Postgres DX / Run Supabase Locally

1. make the email stuff work with the local setup
1. pgTap set up testing framework / run tests on the RPC functions: https://supabase.com/docs/guides/database/extensions/pgtap
1. future:
   - use postmark templates like [this](https://github.com/supabase/auth/issues/304#issuecomment-998029660)

EPIC OF SIGNUPS AND GETTING STARTED AND CONNECTING FRIENDS

1. ~make the signup email nice~

EDGE CASES LEFT BEHIND

1. When you reach the getting-started page with no "user role" set
   - rn the redirect pretends you're a helper
   - we should probably ask ppl instead
   - we should really do away with this "helper" distinction altogether I think? or move it to the deck setup

MOCKS / Incompletes

1. Friends activity ?? (maybe doesn't belong here) - wire it up - move the Quick Search link into the navbar??
1. Public Library is a special browsing experience that needs to be built!
   1. $lang/library has this "recently reviewed" filter which probably should be a field on the user_card_plus view
   1. $lang/index needs the review overview graph thing made

CARD INTERACTIONS

1. "suggest edits to this card"
   - Plan: Allow any logged-in user to submit a change to the `edit_suggestions` table.
1. "edit" feature for editing translations and phrases. a user deck assigns the user's relationship to the language, are they no-relation, curious, learner, friend, teacher, or editor. in this example, editor is the high mark, like an admin.
   - Plan: Users with `editor` role can directly modify records, which calls an `update_*` RPC.
1. "edit history" where you can see the previous edits and timestamps and who edited them.
   - Plan: Create `phrase_versions` and `translation_versions` tables. Edits will create a new version record. A "History" tab will be added to the card UI.

UI POLISH

1. Full multilingual text search:
   - PGroonga: https://supabase.com/docs/guides/database/extensions/pgroonga
   - fulltext search without accents: https://www.postgresql.org/docs/current/unaccent.html
   - ⛔ fuzzy string match that only works well with american names: https://www.postgresql.org/docs/current/fuzzystrmatch.html
1. This chat's features: https://v0.dev/chat/animated-card-interface-MHacnAB0fOp
   1. slide the cards in and out horizontally
   1. give us a completion progress bar in the /review interface

OTHER IDEAS

1. a app shortcut that opens straight into new-card interface
1. take a picture, do OCR on it, let people create a card directly from the real world
1. record voicenote, extract card(s) from it, like making your own playlist on the spot
1. Prettier URLs? with hashIDs (can hash the uuid): https://supabase.com/docs/guides/database/extensions/pg_hashids

STANDARDIZINGS

This section is for when we have a new/second implementation of something and we want to either merge the two or use the second one for the first instance (removing the old component or function).

- The search interface in the chat should be replaced in some way with the search interface for `/learn/browse`

AUTH GUARDS THAT NEED GUARDING

- the getting-started page -- the redirect should only fire if logged in, and the page itself should have a guard
