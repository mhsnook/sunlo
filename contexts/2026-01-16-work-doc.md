# Sprint Doc

## Completed items list:

Update this list with complexity and difficulty scores after completing an item.

- [x] (c2, d2) DX: GitHub actions for CI/CD
- [x] (c2, d2) DX: Navigating-around-the-app tests
- [x] (c2, d2) Chore: Retire PLv8, move FSRS to client
- [x] (c1, d1) Feat: catch login on signup page and show better feedback
- [x] (c2, d1) Feat: edit or archive translations
- [x] (c1, d1) Fix: query collection errors on logout/login
- [x] (c2, d2) Feat: Only-Reverse-Reviews setting for some cards
- [x] (c2, d2) Fix: Auth state transition bugs (sign out + login race conditions)

## BLOCKING MERGE

These items are blocking our merge and must be addressed first and foremost.

### A REGRESSION: SIGN OUT IS NOT WORKING. And the new `utils.refresh` logic on sign in seems to sometimes result in getting past the profile loader / suspense boundary and then getting redirected to the getting-started page and then add-deck when the promise resolves.

STATUS: COMPLETE
COMPLEXITY: 2
DIFFICULTY: 3 (Required multiple rounds of debugging due to layered caching issues)

FIXES APPLIED (Session 1):

1. **Changed `useProfile` from `useLiveSuspenseQuery` to `useLiveQuery`** (`src/hooks/use-profile.ts`):
   - The suspense query would suspend forever or error when the collection was cleaned up after sign out
   - The non-suspense `useLiveQuery` gracefully returns `undefined` when there's no data (logged out or collection cleaned up)
   - This allows components to simply check `if (!profile)` instead of suspending

2. **Removed duplicate `clearUser()` call from `nav-user.tsx`**:
   - `clearUser()` was being called twice during sign out: once in auth-context.tsx (on SIGNED_OUT event) and once in nav-user.tsx (onSettled)
   - Removed the duplicate call from nav-user.tsx to avoid race conditions

3. **Added `queryClient.ensureQueryData` in `_user.tsx` loader** (from previous session):
   - Fixed race condition where login would navigate to /learn before profile collection was loaded
   - The loader now properly waits for the profile query to complete

4. **Updated `getting-started.tsx` to check for existing decks** (from previous session):
   - Prevents redirect to /learn/add-deck for users who already have decks

FIXES APPLIED (Session 2 - Root causes found):

5. **Added React Query cache clearing to `clearUser()`** (`src/lib/collections.ts`):
   - The collections were being cleaned up, but the React Query cache backing them wasn't
   - Added `queryClient.removeQueries({ queryKey: ['user'] })` to clear all user query cache
   - This ensures stale data doesn't persist after sign out

6. **Fixed home page `UserLogin` component** (`src/routes/index.tsx`):
   - Component was only checking `useProfile()` data, not auth state
   - Added auth state check via `Route.useRouteContext()` - if not authenticated, always show login link
   - This prevents showing the avatar when stale profile data exists in cache

7. **Improved `_user.tsx` loader robustness**:
   - Changed from `ensureQueryData` to `fetchQuery` with short `staleTime: 1000`
   - This ensures fresh data is fetched after login instead of using potentially stale cache
   - Simplified the collection state checking logic

8. **Added new test case** (`auth-state-transitions.spec.ts`):
   - Added explicit test for home page showing login link (not avatar) after sign out
   - Now has 9 tests covering auth state transitions

9. **Handle 403 errors during sign out** (`nav-user.tsx`):
   - When Supabase returns 403 (session already invalid server-side), the error was being returned but not handled
   - Now catches the error and manually clears localStorage tokens via `removeSbTokens()`
   - Also calls `clearUser()` to clear all user collections
   - Navigates to home regardless of success/error

All 9 auth state transition tests pass consistently.



## Instructions for the coding agent

Under normal circumstances you will start by looking through the document for items that are pending or in an otherwise "ready" state, and then you'll attempt to do it! (Revert your changes and move on after 3 missed attempts.) If you think you've succeeded at an item, run the tests and the linters, and fix things until they pass. It's very important after every item, whether you completed it, or just did some research, or tried and failed, you must add a DIFFICULTY score (1-to-4) underneath the COMPLEXITY score. (It does NOT have to be the same; it is used to give us information about when we have guessed incorrectly.) Then add whatever notes you want, for later, git commit, and move on. If the commit fails, fix any errors and commit again. If you make migrations, you can run `pnpm db-full` to run the migrations and update the types, but then you have to STOP and ask the human manager to handle the changes to the `base.sql` schema. But so when you're done, regardless of the status, update the item with a new status, difficulty, and your notes, and move on to the next one. You do not have to go in any order. If something is large enough to warrant its own project doc, like a difficulty of 3 or 4, then make your own project doc and wait for human feedback before moving ahead to implementation.

If you have been instructed to do a BIG ITEMS PASS, then do one thing differently: start first by looking at the items that are marked as BIG ITEMS, or that you can see require analysis or have a complexity of 3 or 4. Otherwise, work through the doc item by item picking the ones most relevant to you, as you normally would, but not writing any code or doing any git commits, simply leaving your analysis and plans on these items and moving on.

## Items to Work On

### Feature E: Friends feed and Popular feed should become polymorphic like the recent feed, and Filters should work there too

STATUS: PENDING
COMPLEXITY: 2

NOTE: The router's fallback loading component wasn't using the standard Loader component; switching to that fixed it.

### Feature Research H: User Consents and GDPR

STATUS: PENDING
COMPLEXITY: 1 or 3

HUMAN MANAGER COMMENT: Now that we have a "public mode" we have an increased responsibility and urgency around implementing some more explicit permissions and consents. For example, the privacy policy in `privacy-policy.tsx` specifies that phrases and translations will be public, but we should make this more clear that e.g. comment threads, requests and playlists are also part of the public resources. Which cards you're learning and your review history are private, but many of these other things can be read by the public. Giving some checkbox notification of this, on the signup form, should be a simple client-side change (complexity 1).

And in time we also need to implement some GDPR compliance, which means having a model for consents and consent-agreement actions that can be tied back to the version of the policy that was being consented to. Which means probbly moving the privacy policy into the database as markdown and versioning it and so on. This will be a much more involved project than simply better notifying the users about sharing information in public, and should be well thought out before we begin.

### Feature I: Sign in with Google Auth

STATUS: Pending
COMPLEXITY: 2

HUMAN MANAGER COMMENT: This may require some back-and-forth with Supabase setup and configuration, and then writing code. And we may need to give individuals a way to switch from password-auth to google-auth.

### S. Feature: Reverse Reviews

STATUS: COMPLETE
COMPLEXITY: 2
DIFFICULTY: 2

IMPLEMENTATION NOTES:

Added `only_reverse` boolean field to the `phrase` table (phrase-level, public setting). When true, the phrase should only be reviewed in reverse direction (translation → phrase). Use case: phrases like "ek do thin char panch" (Hindi for 1,2,3,4,5) where seeing the target language is obvious but recalling it from the translation is the challenge.

Changes made:

1. **Migration** (`20260116195845_add_phrase_no_reverse.sql`):

   - Added `only_reverse` column to phrase table
   - Updated `phrase_with_translations_input` type with `only_reverse` field
   - Updated `bulk_add_phrases` RPC to accept and store the flag
   - Added `phrase_only_reverse` parameter to `add_phrase_translation_card` RPC
   - Included DROP FUNCTION to avoid overloaded function signatures

2. **Schema** (`schemas.ts`): Added `only_reverse` to `PhraseFullSchema`

3. **UI**: Added "Only reverse reviews make sense" checkbox to:

   - `$lang.bulk-add.tsx` - per-phrase checkbox in each phrase entry
   - `$lang.add-phrase.tsx` - checkbox with live card preview (forward card grays out when checked)
   - `inline-phrase-creator.tsx` - compact checkbox

4. **Review logic** (`review-single-card.tsx`): Updated to respect `only_reverse` flag:
   - When `only_reverse` is true, shows translation first and reveals phrase on click
   - Button text changes to "Show Phrase" instead of "Show Translation"

NOTE FROM HUMAN MANAGER: the card shouldn't always be shown on the front, should it? sometimes we need to see the translation and remember the phrase (or see the request??). What do you think?

### Feature: Bidirectional Cards (Anki-style)

STATUS: PENDING - PROJECT DOC CREATED
COMPLEXITY: 3

See `contexts/project-bidirectional-cards.md` for full design.

Summary: Each phrase generates two independently-scheduled cards (forward and reverse). Learning "casa → house" vs "house → casa" are different skills that strengthen at different rates. Includes bury-sibling logic to prevent seeing both in the same session. Integrates with `only_reverse` feature (phrases marked only_reverse skip forward card creation).

### X. Chore: 1. Replace the friend request / accept / cancel logic with a dedicated RPC

STATUS: PENDING
COMPLEXITY: 2 (simple enough, but requires migrations and checking state/idempotence/edge cases (like both people sending requests at the same time))

## Items that still need to be figured out

Feeds Work Cleanup tasks:

2. Need to be able to "repost" a Request to a new language
3. Playlists should have an image option if you don't have an external source with og:image

EPIC: Postgres DX / Run Supabase Locally

1. make the email stuff work with the local setup
1. pgTap set up testing framework / run tests on the RPC functions: https://supabase.com/docs/guides/database/extensions/pgtap
1. future:
   - use postmark templates like [this](https://github.com/supabase/auth/issues/304#issuecomment-998029660)

EPIC OF SIGNUPS AND GETTING STARTED AND CONNECTING FRIENDS

1. ~make the signup email nice~

EDGE CASES LEFT BEHIND

1. When you reach the getting-started page with no "user role" set
   - rn the redirect pretends you're a helper
   - we should probably ask ppl instead
   - we should really do away with this "helper" distinction altogether I think? or move it to the deck setup

MOCKS / Incompletes

1. Friends activity ?? (maybe doesn't belong here) - wire it up - move the Quick Search link into the navbar??
1. Public Library is a special browsing experience that needs to be built!
   1. $lang/library has this "recently reviewed" filter which probably should be a field on the user_card_plus view
   1. $lang/index needs the review overview graph thing made

CARD INTERACTIONS

1. "suggest edits to this card"
   - Plan: Allow any logged-in user to submit a change to the `edit_suggestions` table.
1. "edit" feature for editing translations and phrases. a user deck assigns the user's relationship to the language, are they no-relation, curious, learner, friend, teacher, or editor. in this example, editor is the high mark, like an admin.
   - Plan: Users with `editor` role can directly modify records, which calls an `update_*` RPC.
1. "edit history" where you can see the previous edits and timestamps and who edited them.
   - Plan: Create `phrase_versions` and `translation_versions` tables. Edits will create a new version record. A "History" tab will be added to the card UI.

UI POLISH

1. Full multilingual text search:
   - PGroonga: https://supabase.com/docs/guides/database/extensions/pgroonga
   - fulltext search without accents: https://www.postgresql.org/docs/current/unaccent.html
   - ⛔ fuzzy string match that only works well with american names: https://www.postgresql.org/docs/current/fuzzystrmatch.html
1. This chat's features: https://v0.dev/chat/animated-card-interface-MHacnAB0fOp
   1. slide the cards in and out horizontally
   1. give us a completion progress bar in the /review interface

OTHER IDEAS

1. a app shortcut that opens straight into new-card interface
1. take a picture, do OCR on it, let people create a card directly from the real world
1. record voicenote, extract card(s) from it, like making your own playlist on the spot
1. Prettier URLs? with hashIDs (can hash the uuid): https://supabase.com/docs/guides/database/extensions/pg_hashids

STANDARDIZINGS

This section is for when we have a new/second implementation of something and we want to either merge the two or use the second one for the first instance (removing the old component or function).

- The search interface in the chat should be replaced in some way with the search interface for `/learn/browse`

AUTH GUARDS THAT NEED GUARDING

- the getting-started page -- the redirect should only fire if logged in, and the page itself should have a guard

OTHER:

- Upgrade to FSRS v6
- Get rid of the user_card_plus and instead have empty stats fields that get updated with a trigger
- standardize URLs: `learn/$lang/phrases/new` not `learn/$lang/add-phrases`
- Need discussion about phrases and playlists
- Need to implement Tags also; starting with user-tags that just mirror playlists.
- we don't need bulk-add anymore bc the add-phrase is just really nice and instant. we need easy edits by the creator with a carefully crafted message about the importance of not changing the original intent/implications/difficulty of the phrase because other people are trying to learn it and it will mess up their thing. then we can safely remove bulk-add route and form, and add functionality to the add-phrase form and RPC function to accept an array of translation items and use the existing DB type for a phrase input and its translations.
- playlists should also take featured images / ingest og image for default